<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>POL/USDT — Multi-DEX Comparator & Profit Estimator</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; background:#f5f7fb; color:#111; padding:20px; }
    h1 { margin:0 0 8px 0; font-size:20px }
    .controls { margin:12px 0; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    input[type="number"] { padding:8px; border-radius:8px; border:1px solid #ddd; width:140px; }
    button { padding:8px 12px; border-radius:8px; border:none; background:#2563eb; color:white; cursor:pointer; }
    button:disabled { opacity:.6; cursor:not-allowed }
    .grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); gap:12px; margin-top:16px;}
    .card { background:white; border-radius:10px; padding:14px; box-shadow:0 2px 8px rgba(15,23,42,0.05); }
    table { width:100%; border-collapse:collapse; font-size:13px; margin-top:8px }
    th, td { text-align:left; padding:6px 8px; border-bottom:1px solid #f0f2f6 }
    .good { color: #065f46; font-weight:600 }
    .bad { color: #991b1b; font-weight:600 }
    .muted { color:#6b7280 }
    code { background:#eef2ff; padding:2px 6px; border-radius:6px }
  </style>
</head>
<body>
  <h1>POL / USDT — Multi-DEX Comparator & Profit Estimator</h1>
  <div class="muted">Reads prices on-chain from routers (no external API). Ensure MetaMask on Polygon Mainnet.</div>

  <div class="controls">
    <button id="connectBtn">Connect MetaMask</button>
    <button id="checkBtn" disabled>Check Prices</button>

    <label class="muted">Amount POL:</label>
    <input id="amountPOL" type="number" step="0.0001" value="1" />

    <label class="muted">Amount USDT:</label>
    <input id="amountUSDT" type="number" step="0.01" value="10" />

    <label class="muted">Auto-refresh:</label>
    <input id="autorefr" type="checkbox" />
    <div style="margin-left:auto" class="muted">Note: results ignore gas & frontrunning; just raw on-chain swap math.</div>
  </div>

  <div class="grid">
    <div class="card">
      <h3>DEX Prices (1 POL)</h3>
      <div id="pricesSummary">-</div>
    </div>

    <div class="card">
      <h3>USDT → POL (buy then sell) — Profit in USDT</h3>
      <div id="usdtToPol">-</div>
    </div>

    <div class="card">
      <h3>POL → USDT (sell then rebuy) — Profit in POL</h3>
      <div id="polToUsdt">-</div>
    </div>

    <div class="card">
      <h3>Best Opportunities</h3>
      <div id="bestOpp">-</div>
    </div>
  </div>

  <script>
    (function(){
      // Routers (4 DEX)
      const ROUTERS = {
        quick: { name: "QuickSwap", addr: "0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff" },
        sushi: { name: "SushiSwap", addr: "0x1b02da8cb0d097eb8d57a175b88c7d8b47997506" },
        mesh:  { name: "MeshSwap",  addr: "0x10f4A785F458Bc144e3706575924889954946639" },
        ape:   { name: "ApeSwap",   addr: "0xC0788A3aD43d79aa53B09c2EaCc313A787d1d607" }
      };

      // Token addresses (use the ones you confirmed)
      const POL  = "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270"; // wrapped POL (18)
      const USDT = "0x170A18B9190669Cda08965562745A323C907E5Ec"; // pUSDt (6) — use the one you provided

      // ABI minimal
      const ABI = [
        "function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts)"
      ];

      // DOM
      const connectBtn = document.getElementById("connectBtn");
      const checkBtn = document.getElementById("checkBtn");
      const amountPOLInput = document.getElementById("amountPOL");
      const amountUSDTInput = document.getElementById("amountUSDT");
      const pricesSummary = document.getElementById("pricesSummary");
      const usdtToPolDiv = document.getElementById("usdtToPol");
      const polToUsdtDiv = document.getElementById("polToUsdt");
      const bestOppDiv = document.getElementById("bestOpp");
      const autorefr = document.getElementById("autorefr");

      let provider = null;
      let refreshInterval = null;

      // helper: format number safely
      function fnum(x, decimals=6) {
        if (x === null || x === undefined || isNaN(x)) return "-";
        return Number(x).toFixed(decimals);
      }

      // connect
      connectBtn.onclick = async () => {
        if (!window.ethereum) return alert("Please install MetaMask");
        provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        const net = await provider.getNetwork();
        if (net.chainId !== 137) {
          alert("Switch MetaMask to Polygon Mainnet (chainId 137)");
        } else {
          alert("Connected to Polygon");
          checkBtn.disabled = false;
        }
      };

      // main check function
      checkBtn.onclick = async () => {
        await runCheck();
      };

      // auto-refresh
      autorefr.onchange = () => {
        if (autorefr.checked) {
          if (!provider) return alert("Connect first");
          refreshInterval = setInterval(() => runCheck().catch(console.error), 30000);
        } else {
          clearInterval(refreshInterval);
        }
      };

      async function callGetAmounts(routerAddr, amountIn, path) {
        try {
          const c = new ethers.Contract(routerAddr, ABI, provider);
          const amounts = await c.getAmountsOut(amountIn, path);
          return amounts; // array of BigNumber
        } catch (e) {
          // console.warn("router call failed", routerAddr, e.message);
          return null;
        }
      }

      async function runCheck() {
        if (!provider) return alert("Please connect MetaMask first");
        // read inputs
        const amountPOL = parseFloat(amountPOLInput.value) || 1;
        const amountUSDT = parseFloat(amountUSDTInput.value) || 10;

        // prepare BN
        const amountPOL_BN = ethers.utils.parseUnits(amountPOL.toString(), 18); // 18
        const amountUSDT_BN = ethers.utils.parseUnits(amountUSDT.toString(), 6); // 6

        // fetch direct prices 1 POL -> USDT for each router
        const priceMap = {};
        pricesSummary.innerText = "Fetching...";
        const pathPOLtoUSDT = [POL, USDT];
        for (const key of Object.keys(ROUTERS)) {
          const router = ROUTERS[key];
          const res = await callGetAmounts(router.addr, ethers.utils.parseUnits("1", 18), pathPOLtoUSDT);
          if (res && res.length > 1) {
            priceMap[key] = { rawUSDT: res[1], price: parseFloat(ethers.utils.formatUnits(res[1], 6)) };
          } else {
            priceMap[key] = { rawUSDT: null, price: NaN };
          }
        }

        // show summary
        let sumHtml = "<table><thead><tr><th>DEX</th><th>1 POL → USDT</th></tr></thead><tbody>";
        for (const k of Object.keys(ROUTERS)) {
          const p = priceMap[k];
          sumHtml += `<tr><td>${ROUTERS[k].name}</td><td>${isFinite(p.price) ? p.price.toFixed(6) + " USDT" : "<span class='muted'>-</span>"}</td></tr>`;
        }
        sumHtml += "</tbody></table>";
        pricesSummary.innerHTML = sumHtml;

        // === USDT -> POL arbitrage (start with amountUSDT)
        // For each buyDex: USDT -> POL (get POL_bought)
        // Then for each sellDex: POL_bought -> USDT_result
        usdtToPolDiv.innerHTML = "Calculating...";
        const usdtPath = [USDT, POL];
        const usdtResults = []; // {buyDex, sellDex, usdtIn, usdtOut, profitUSDT, profitPct}
        // precompute POL amounts for buying on each buyDex
        const polBoughtByDex = {};
        for (const buyKey of Object.keys(ROUTERS)) {
          const buyRouter = ROUTERS[buyKey];
          const buyRes = await callGetAmounts(buyRouter.addr, amountUSDT_BN, usdtPath);
          if (buyRes && buyRes.length > 1) {
            polBoughtByDex[buyKey] = buyRes[1]; // BigNumber POL (18)
          } else {
            polBoughtByDex[buyKey] = null;
          }
        }
        // for each buy/sell pair compute profit
        for (const buyKey of Object.keys(ROUTERS)) {
          for (const sellKey of Object.keys(ROUTERS)) {
            if (polBoughtByDex[buyKey] === null) continue;
            const sellRouter = ROUTERS[sellKey];
            // sell that POL on sellRouter
            const sellRes = await callGetAmounts(sellRouter.addr, polBoughtByDex[buyKey], pathPOLtoUSDT);
            if (!sellRes || sellRes.length <= 1) continue;
            const usdtOutBN = sellRes[1];
            const usdtOut = parseFloat(ethers.utils.formatUnits(usdtOutBN, 6));
            const profit = usdtOut - amountUSDT;
            const profitPct = (profit / amountUSDT) * 100;
            usdtResults.push({
              buyDex: buyKey, sellDex: sellKey,
              buyName: ROUTERS[buyKey].name, sellName: ROUTERS[sellKey].name,
              usdtIn: amountUSDT, usdtOut, profit, profitPct
            });
          }
        }

        // render USDT->POL table (sort by profit desc)
        usdtResults.sort((a,b) => b.profit - a.profit);
        if (usdtResults.length === 0) {
          usdtToPolDiv.innerHTML = "<div class='muted'>No valid USDT→POL->USDT paths found (liquidity missing).</div>";
        } else {
          let html = "<table><thead><tr><th>Buy (USDT→POL)</th><th>Sell (POL→USDT)</th><th>In USDT</th><th>Out USDT</th><th>Profit USDT</th><th>%</th></tr></thead><tbody>";
          for (const r of usdtResults) {
            html += `<tr>
              <td>${r.buyName}</td>
              <td>${r.sellName}</td>
              <td>${r.usdtIn.toFixed(6)}</td>
              <td>${r.usdtOut.toFixed(6)}</td>
              <td class="${r.profit>0?'good':'bad'}">${r.profit.toFixed(6)}</td>
              <td>${r.profitPct.toFixed(3)}%</td>
            </tr>`;
          }
          html += "</tbody></table>";
          usdtToPolDiv.innerHTML = html;
        }

        // === POL -> USDT arbitrage (start with amountPOL)
        polToUsdtDiv.innerHTML = "Calculating...";
        const polResults = []; // {sellDex, buyDex, polIn, polOut, profitPOL, profitPctPOL}
        // precompute USDT obtained by selling POL on each sellDex
        const usdtFromSelling = {};
        for (const sellKey of Object.keys(ROUTERS)) {
          const sellRouter = ROUTERS[sellKey];
          const sellRes = await callGetAmounts(sellRouter.addr, amountPOL_BN, pathPOLtoUSDT);
          if (sellRes && sellRes.length > 1) {
            usdtFromSelling[sellKey] = sellRes[1]; // BigNumber USDT (6)
          } else {
            usdtFromSelling[sellKey] = null;
          }
        }
        // for each sell/buy pair compute profit in POL
        for (const sellKey of Object.keys(ROUTERS)) {
          if (!usdtFromSelling[sellKey]) continue;
          for (const buyKey of Object.keys(ROUTERS)) {
            // buy POL back with usdtFromSelling[sellKey] on buyRouter
            const buyRouter = ROUTERS[buyKey];
            const buyRes = await callGetAmounts(buyRouter.addr, usdtFromSelling[sellKey], usdtPath);
            if (!buyRes || buyRes.length <= 1) continue;
            const polAfterBN = buyRes[1];
            const polAfter = parseFloat(ethers.utils.formatUnits(polAfterBN, 18));
            const profitPOL = polAfter - amountPOL;
            const profitPctPOL = (profitPOL / amountPOL) * 100;
            polResults.push({
              sellDex: sellKey, buyDex: buyKey,
              sellName: ROUTERS[sellKey].name, buyName: ROUTERS[buyKey].name,
              polIn: amountPOL, polOut: polAfter, profitPOL, profitPctPOL
            });
          }
        }

        // render POL->USDT table sorted by profit in POL desc
        polResults.sort((a,b) => b.profitPOL - a.profitPOL);
        if (polResults.length === 0) {
          polToUsdtDiv.innerHTML = "<div class='muted'>No valid POL→USDT→POL paths found (liquidity missing).</div>";
        } else {
          let html = "<table><thead><tr><th>Sell (POL→USDT)</th><th>Buy (USDT→POL)</th><th>In POL</th><th>Out POL</th><th>Profit POL</th><th>%</th></tr></thead><tbody>";
          for (const r of polResults) {
            html += `<tr>
              <td>${r.sellName}</td>
              <td>${r.buyName}</td>
              <td>${r.polIn.toFixed(6)}</td>
              <td>${r.polOut.toFixed(6)}</td>
              <td class="${r.profitPOL>0?'good':'bad'}">${r.profitPOL.toFixed(6)}</td>
              <td>${r.profitPctPOL.toFixed(3)}%</td>
            </tr>`;
          }
          html += "</tbody></table>";
          polToUsdtDiv.innerHTML = html;
        }

        // Best opportunities summary
        let best = [];
        if (usdtResults.length) {
          const top = usdtResults[0];
          best.push(`USDT→POL: Buy ${top.buyName}, Sell ${top.sellName} → Profit ${top.profit.toFixed(6)} USDT (${top.profitPct.toFixed(3)}%)`);
        }
        if (polResults.length) {
          const top2 = polResults[0];
          best.push(`POL→USDT: Sell ${top2.sellName}, Buy ${top2.buyName} → Profit ${top2.profitPOL.toFixed(6)} POL (${top2.profitPctPOL.toFixed(3)}%)`);
        }
        bestOppDiv.innerHTML = best.length ? `<ul>${best.map(x=>`<li>${x}</li>`).join("")}</ul>` : "<div class='muted'>No profitable paths found (ignoring gas & slippage protection).</div>";
      } // end runCheck

    })();
  </script>
</body>
</html>
